package db

import (
	"context"
	"database/sql"
	"fmt"
)

type Store interface {
	// TODO: add functions to this interface
	Querier
	// InsertStudentTx(ctx context.Context, arg InsertStudentTxParams) (InsertStudentTxResult, error)
	// InsertAdminTx(ctx context.Context, arg InsertAdminTxParams) (InsertAdminTxResult, error) 
}

type SQLStore struct {
	*Queries
	// this object is used to create a new db transaction.
	db *sql.DB
}

//Although we have changed the Store type from struct to interface, our code will still work well,
//and we don’t have to change anything in the main.go file because the db.NewStore() function
//is now also returning a Store interface with the actual implementation SQLStore that connects to the real SQL DB

func NewStore(db *sql.DB) Store {
	// The New() function was generated by sqlc as we’ve already known in the previous lectures. It creates and returns a Queries object.
	//why Store -> return &SQLStore
	return &SQLStore{
		db:      db,
		Queries: New(db),
	}
}

//execTx executes a function within a database transaction
//this function is unexported (it starts with a lowercase letter e), because we don’t want external package to call it directly. Instead, we will provide an exported function for each specific transaction.

func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, &sql.TxOptions{})
	if err != nil {
		return err
	}
	q := New(tx)
	err = fn(q)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
		}
		return err
	}
	return tx.Commit()
}

// type InsertAdminTxParams struct {
// 	AdminID             string `json:"admin_id" `
// 	Password            string `json:"password"`
// 	PublicKey           string `json:"public_key"  `
// 	EncryptedPrivateKey string `json:"encrypted_private_key"  `
// 	Name                string `json:"name" `
// }

// type InsertAdminTxResult struct {
// 	AdminID string `json:"admin_id"`
// 	Name    string `json:"name"`
// }

// func (store *SQLStore) InsertAdminTx(ctx context.Context, arg InsertAdminTxParams) (InsertAdminTxResult, error) {

// 	var result InsertAdminTxResult

// 	err := store.execTx(ctx, func(q *Queries) error {
// 		hashedPassword, err := util.HashPassword(arg.Password)
// 		if err != nil {
// 			return err
// 		}

// 		// create account first
// 		account_arg := CreateAccountParams{
// 			AccountID:           arg.AdminID,
// 			Role:                RoleTypeADMIN,
// 			Password:            hashedPassword,
// 			PublicKey:           arg.PublicKey,
// 			EncryptedPrivateKey: arg.EncryptedPrivateKey,
// 		}

// 		account, err := q.CreateAccount(ctx, account_arg)
// 		if err != nil {
// 			if pqErr, ok := err.(*pq.Error); ok {
// 				switch pqErr.Code.Name() {
// 				case "unique_violation":
// 					return err
// 				}
// 			}
// 			return err
// 		}

// 		fmt.Println(account)

// 		admin_arg := CreateAdminParams{
// 			AdminID:      account.AccountID,
// 			Name:           arg.Name,
// 		}

// 		admin, err := q.CreateAdmin(ctx, admin_arg)
// 		if err != nil {
// 			if pqErr, ok := err.(*pq.Error); ok {
// 				switch pqErr.Code.Name() {
// 				case "unique_violation":
// 					return err
// 				}
// 			}
// 			return err
// 		}
// 		result = InsertAdminTxResult{
// 			AdminID : admin.AdminID,
// 			Name    : admin.Name,
// 		}
// 		return nil
// 	})
// 	return result, err

// }

// type InsertStudentTxParams struct {
// 	StudentID           string     `json:"student_id" binding:"required"`
// 	Password            string     `json:"password" binding:"required,min=6"`
// 	PublicKey           string     `json:"public_key"  binding:"required"`
// 	EncryptedPrivateKey string     `json:"encrypted_private_key"  binding:"required"`
// 	CitizenID           string     `json:"citizen_id" binding:"required,min=6"`
// 	Name                string     `json:"name" binding:"required"`
// 	Gender              GenderType `json:"gender" binding:"required"`
// 	DateOfBirth         string     `json:"date_of_birth" binding:"required,date"`
// 	PlaceOfBirth        string     `json:"place_of_birth" binding:"required"`
// 	Class               string     `json:"class" binding:"required"`
// 	Department          string     `json:"department" binding:"required"`
// 	TimeOfTraining      int32      `json:"time_of_training" binding:"required"`
// 	FormOfTraining      string     `json:"form_of_training" binding:"required"`
// }

// type InsertStudentTxResult struct {
// 	StudentID      string     `json:"student_id"`
// 	CitizenID      string     `json:"citizen_id"`
// 	Name           string     `json:"name"`
// 	Gender         GenderType `json:"gender"`
// 	DateOfBirth    time.Time  `json:"date_of_birth"`
// 	PlaceOfBirth   string     `json:"place_of_birth"`
// 	Class          string     `json:"class"`
// 	Department     string     `json:"department"`
// 	TimeOfTraining int32      `json:"time_of_training"`
// 	FormOfTraining string     `json:"form_of_training"`
// }

// func (store *SQLStore) InsertStudentTx(ctx context.Context, arg InsertStudentTxParams) (InsertStudentTxResult, error) {

// 	var result InsertStudentTxResult

// 	err := store.execTx(ctx, func(q *Queries) error {
// 		hashedPassword, err := util.HashPassword(arg.Password)
// 		if err != nil {
// 			return err
// 		}

// 		dob, err := util.MapStringToTime(arg.DateOfBirth)
// 		if err != nil {
// 			return err
// 		}

// 		// create account first
// 		account_arg := CreateAccountParams{
// 			AccountID:           arg.StudentID,
// 			Role:                RoleTypeSTUDENT,
// 			Password:            hashedPassword,
// 			PublicKey:           arg.PublicKey,
// 			EncryptedPrivateKey: arg.EncryptedPrivateKey,
// 		}

// 		account, err := q.CreateAccount(ctx, account_arg)
// 		if err != nil {
// 			if pqErr, ok := err.(*pq.Error); ok {
// 				switch pqErr.Code.Name() {
// 				case "unique_violation":
// 					return err
// 				}
// 			}
// 			return err
// 		}

// 		fmt.Println(account)

// 		student_arg := CreateStudentParams{
// 			StudentID:      account.AccountID,
// 			CitizenID:      arg.CitizenID,
// 			Name:           arg.Name,
// 			Gender:         arg.Gender,
// 			DateOfBirth:    dob,
// 			PlaceOfBirth:   arg.PlaceOfBirth,
// 			Class:          arg.Class,
// 			Department:     arg.Department,
// 			TimeOfTraining: arg.TimeOfTraining,
// 			FormOfTraining: arg.FormOfTraining,
// 		}

// 		student, err := q.CreateStudent(ctx, student_arg)
// 		if err != nil {
// 			if pqErr, ok := err.(*pq.Error); ok {
// 				switch pqErr.Code.Name() {
// 				case "unique_violation":
// 					return err
// 				}
// 			}
// 			return err
// 		}
// 		result = InsertStudentTxResult{
// 			StudentID:      student.StudentID,
// 			CitizenID:      student.CitizenID,
// 			Name:           student.Name,
// 			Gender:         student.Gender,
// 			PlaceOfBirth:   student.PlaceOfBirth,
// 			Class:          student.Class,
// 			Department:     student.Department,
// 			TimeOfTraining: student.TimeOfTraining,
// 			FormOfTraining: student.FormOfTraining,
// 		}
// 		return nil
// 	})
// 	return result, err

// }
